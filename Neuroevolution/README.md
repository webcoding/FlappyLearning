# 进化算法

进化算法包括遗传算法、遗传规划、进化规划和进化策略等等。进化算法的基本框架还是简单遗传算法所描述的框架，但在进化的方式上有较大的差异，选择、交叉、变异、种群控制等有很多变化，进化算法的大致框图可描述如右图所示：

同遗传算法一样，进化算法的收敛性也有一些结果，文献证明了在保存最优个体时通用的进化计算是收敛的，但进化算法的很多结果是从遗传算法推过去的。

遗传算法对交叉操作要看重一些，认为变异操作是算法的辅助操作；而进化规划和进化策略认为在一般意义上说交叉并不优于变异，甚至可以不要交叉操作。

进化计算是基于自然选择和自然遗传等生物进化机制的一种搜索算法。与普通的搜索方法一样，进化计算也是一种迭代算法，不同的是进化计算在最优解的搜索过程中，一般是从原问题的一组解出发改进到另一组较好的解，再从这组改进的解出发进一步改进。而且在进化问题中，要求当原问题的优化模型建立后，还必须对原问题的解进行编码。进化计算在搜索过程中利用结构化和随机性的信息，使最满足目标的决策获得最大的生存可能，是一种概率型的算法。

一般来说，进化计算的求解包括以下几个步骤：给定一组初始解；评价当前这组解的性能；从当前这组解中选择一定数量的解作为迭代后的解的基础；再对其进行操作，得到迭代后的解；若这些解满足要求则停止，否则将这些迭代得到的解作为当前解重新操作。

以遗传算法为例，其工作步骤可概括为：

1 对工作对象——字符串用二进制的0/1或其它进制字符编码。
1 根据字符串的长度L，随即产生L个字符组成初始个体。
1 计算适应度。适应度是衡量个体优劣的标志，通常是所研究问题的目标函数。
1 通过复制，将优良个体插入下一代新群体中，体现“优胜劣汰”的原则。
1 交换字符，产生新个体。交换点的位置是随机决定的
1 对某个字符进行补运算，将字符1变为0，或将0变为1，这是产生新个体的另一种方法，突变字符的位置也是随机决定的。
1 遗传算法是一个反复迭代的过程，每次迭代期间，要执行适应度计算、复制、交换、突变等操作，直至满足终止条件。

形式化语言表达，则为：假设α∈I记为个体，I记为个体空间。适应度函数记为Φ：I→R。在第t代，群体P(t)={a1(t),a2(t)，…，an(t)}经过复制r(reproduction)、交换c(crossover)及突变m(mutation)转换成下一代群体。这里r、c、m均指宏算子，把旧群体变换为新群体。L：I→{True, Flase}记为终止准则。利用上述符号，遗传算法可描述为：

```desc
t=0
initialize P(0):={ a1(0),a2(0)，…，an(0)};
while(l(P(t))≠True) do
  evaluate P(t):{ Φ(a1(t)), Φ(a2(t))，…，Φ(an(t))};
  reproduction: P′(t):=r(P(t));
  crossover: P″(t):=c(P′(t));
  mutation: P(t+1):= m(P″(t));
  t=t+1;
end
```


进化算法是以达尔文的进化论思想为基础，通过模拟生物进化过程与机制的求解问题的自组织、自适应的人工智能技术。生物进化是通过繁殖、变异、竞争和选择实现的；而进化算法则主要通过选择、重组和变异这三种操作实现优化问题的求解。如下

```desc
t=0
初始化群体p(0)
评估初始化群体p(0)
while终止条件不满足do
  重组操作：p(t)=r(p(t))
  变异操作：p(t)=m(p(t))
  评估操作：p(t)
  选择操作：p(t+1)=s(p(t)UQ)
  t=t+1
end
```

其中r、m、s分别表示重组算子、变异算子、选择算子。图1：进化算法基本框架



- Neuron
- Layer
- Network
- Genome
- Generation
- Generations
- Self
